/*------------------------------------------------------------------------------------------                                                                                            *  
|                        CRW-X非接触读卡器应用编程接口(API)说明                                            
|				                                                      
|				                            Version 10.02                                                    
|                                                                                            
|     	1. PC与读卡器通讯协议   
|          扩展的T=1协议 (CRW系列读卡器通用协议) 
|	         Nad Pcb Len Cla Ins P1 P2 Lc (Data) Xor	
|
|     	2. 系统文件说明 
|           wdcrwx.sys/wdcrwx.inf  		CRW-X读写器USB驱动程序
|	          wdcrwx.dll/wdcrwx.lib/wdcrwx.h	CRW-X读卡器二次开发动态库
|  
|       3. 适用操作系统: 
|	         Windows 98(SE)/Me/NT/2000/XP/Server 2003 环境
|                           
|       4. 读写器可操作的IC卡  
|	         符合ISO/IEC 14443 的非接触CPU卡
|	         符合Mifare one的非接触存储卡 		
|          符合ISO 7816-1/2/3的CPU卡(T=0、1)                                        
|                                                                                            
|	      北京握奇数据系统有限公司机具开发中心                                   
|		              2008-06                                                  
|---------------------------------------------------------------------------------------------*/

#include <windows.h> 

#ifdef __cplusplus
extern "C"{
#endif

/*-------------------------------------------------------------------------------------------
|
|					   一. 读卡器及CPU卡读写接口函数
|   推荐的函数调用顺序 
|
|   CT_open      打开设备获得设备句柄      
|   ICC_reset    对IC卡复位
|   ...
|   ICC_tsi_api等函数对非接触卡(PSAM卡)进行操作
|   ...
|   CT_close     关闭打开设备的连接
|		
--------------------------------------------------------------------------------------------*/
 
/*-------------------------------------------------------------------------------------------
| 1. 打开IC卡终端端口
|    入口参数:
|       (A) 串行口读卡器  
|           name:    可取"COM1", "COM2", "COM3", "COM4"等,字母大小写无关(以下name也一样)
|	          param1:  波特率,9600/19200/57600/115200
|           param2:  校验位,可为'E' 偶校验, 'N' 无校验,无特殊要求,一般使用偶校验即可 
|
|       (B) USB读卡器 
|           name: 可取"USB1", "USB2", "USB3", "USB4"等
|                 USB序号分配原则
|                 1. 从当前系统已由设备插入的顺序决定,第一次插入的设备为USB1,第二次插入设备为USB2
|                     依次类推; 
|                 2. 当新插入USB设备时驱动从1开始查询当前未使用的序号,只到找到为止;
|	          param1:  打开设备的模式 1：共享模式 2：独占模式
|           param2:  未使用,设为0        
|
|   返回值: 
        INVALID_HANDLE_VALUE(-1) 表示打开端口失败;
|		    其他值(大于0)为打开的端口句柄,用于卡操作函数的fd
--------------------------------------------------------------------------------------------*/
HANDLE WINAPI CT_open(
	char           *name,
	unsigned int   param1,
	unsigned char  param2
	); 															
	                                                                                        
/*------------------------------------------------------------------------------------
| 2. 关闭与IC卡读写器相连的端口(必需用CT_open打开的端口                                    
|    入口参数: 
|         fd为函数CT_open所返回的句柄
|    返回值: 
|         -1为失败  0 成功.
|
--------------------------------------------------------------------------------------*/
int WINAPI CT_close(HANDLE fd);                                                      

/*------------------------------------------------------------------
|  
| 3. 从外设向CPU卡或读卡器发送命令APDU并接收应答APDU
|	   comm的结构: CLA INS P1 P2 Lc DATA [Le]  其中DATA长度为Lc字节
|	   resp的结构: DATA                        其中DATA长度为Le字节                                 
|    
|    参数:
|         fd:    已打开的端口描述符.
|         len:   命令comm的长度
|         comm:  发向卡上的命令
|         lenr:  从卡上接收到的数据长度
|         resp:  从卡上接收到的数据
|     返回值:
|	        0xffff通迅失败(发送命令或接收返回的数据失败.
|         其它为从卡上返回的状态SW1 SW2
|     说明:
|         该函数适用于所有CPU卡操作
| 
-------------------------------------------------------------------*/
unsigned WINAPI ICC_tsi_api(
	HANDLE fd,
	unsigned char len,
	unsigned char *comm,
	unsigned char *lenr,
	unsigned char *resp
	);  

/*------------------------------------------------------------------------
|  
|  4. 从外设向CPU卡发送命令APDU并接收应答APDU(针对CRW-X读卡器专用)
|	    comm的结构: CLA INS P1 P2 Lc DATA [Le]  其中DATA长度为Lc字节
|	    resp的结构: DATA                        其中DATA长度为Le字节    
|	    
|     参数:
|	         fd:   已打开的端口描述符.
|          len:  命令comm的长度
|          comm: 发向卡上的命令
|          lenr: 从卡上接收到的数据长度
|          resp: 从卡上接收到的数据
|     返回值: 
|          0xffff通迅失败(发送命令或接收返回的数据失败.
|          其它为从卡上返回的状态SW1 SW2
|
|     说明: 
|         该函数适用于在CRW-X读卡器读写T=0的支持511字节读,511字节写的CPU卡,
|         或其他大于255字节的卡读写操作 
|         使用该函数一次可读写多达511个字节的数据,而函数ICC_tsi_api
|         一次最多可读253个字节,写250个字节
---------------------------------------------------------------------------*/
UINT WINAPI ICC_TransmitAPDU32(
   HANDLE   hDev,
   WORD    len,
   PBYTE    comm,
   PWORD   lenr,
   PBYTE    resp
   );

/*-----------------------------------------------------------------
|
| 5. 设置CPU卡读写地址NAD                                         
|	   参数: 
|         NAD读写地址
|
|    返回值: 无
|	   说明: 
|         该函数使用于CRW-V(VI)系列读卡器,系统缺省值为00
|         00 对主卡操作
|         12 对读写器操作/或对主卡进行操作
|         13 选择双卡座读写器的SAM卡或选择三卡座读写器的SAM1卡,
|	        14 对三卡座读写器选择SAM2卡 
|
-----------------------------------------------------------------*/
 void WINAPI ICC_set_NAD(HANDLE fd,unsigned char nad);                                   
 
/*-----------------------------------------------------------------------------
|                  
|				                 二. Mifare 1 专用接口   
|
|Mifare 1 专用接口返回状态的意义
|    0x9000, 操作成功
|    0x6982, 安全状态不满足（未经过认证）
|    0x6283, 认证密钥错误
|　　0x6ff1, 通讯时编解码格式错误
|　  0x6ff2, 响应位长度错误
|　　0x6ff3, 写卡错误
|　　0x6ff4, 钱包金额错误
|　　0x6ff5, 通讯超时
|    0x6ff6, 密钥格式错误
|
------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------
|
|  1.Mifare 1卡复位 
|   
|    参数: 
|     fd:     已打开的端口描述符
|	    len:    返回数据的长度
|	    resp:   读出的数据
|   
---------------------------------------------------------------------------*/
unsigned WINAPI Mifare1_Reset(                                                                               
	HANDLE fd,
	unsigned char *len,
	unsigned char *resp
	);         
             
/*--------------------------------------------------------------------------
|
|  2. 将所给定的密钥转换为RC531所要求的标准格式后，
|     存入该扇区对应的RC531的密钥存储区EEPROM中
|   
|    参数: 
|     fd:        已打开的端口描述符
|	    SectorNum: 扇区号(0-32)
|	    bKeyType:  密钥类型: 0, KeyA; 1, KeyB
|	    uKey:      6字节的密钥值
|   
---------------------------------------------------------------------------*/
unsigned WINAPI Mifare1_RC531Key(                                                                               
	HANDLE        fd,
	unsigned int  SectorNum,
	BOOL          bKeyType,
	unsigned char *uKey
	);                      

/*--------------------------------------------------------------------------
|
|  3. 密钥认证
|   
|    参数: 
|       fd:        已打开的端口描述符
|       bAuthType: 认证类型。1, 利用指令中给定的密钥进行认证; 
|                            0, 利用RC531存储密钥区（EEPROM）中对应的密钥进行认证
|	      BlockNum:  待认证的块号(0-0x80)
|	      bKeyType:  密钥类型: 0, KeyA; 1, KeyB
|	      uKey:      6字节的密钥值(只在bAuthType = 1时有效)
|   
---------------------------------------------------------------------------*/
unsigned WINAPI Mifare1_Verify(                                                                               
	HANDLE        fd,
	BOOL          bAuthType,
	unsigned int  BlockNum,
	BOOL          bKeyType,
	unsigned char *uKey
	);                      

/*--------------------------------------------------------------------------
|
|  4. 读Mifare 1 卡
|   
|    参数: 
|       
|     fd      : 已打开的端口描述符
|	    BlockNum: 欲读的已经过认证的块号(0-0x80)
|	    resp    : 读出的数据
|    
--------------------------------------------------------------------------*/
unsigned WINAPI Mifare1_Read(                                                                               
	HANDLE        fd,
	unsigned int  BlockNum,
	unsigned char *resp
	);                      

/*--------------------------------------------------------------------------
|
|  5. 写Mifare 1 卡
|   
|    参数: 
|     fd:       已打开的端口描述符
|	    BlockNum: 欲写入的已经过认证的块号(0-0x80)
|	    uData    : 欲写入的数据（16字节）
|   
---------------------------------------------------------------------------*/
unsigned WINAPI Mifare1_Write(                                                                               
	HANDLE        fd,
	unsigned int  BlockNum,
	unsigned char *uData
	); 

/*--------------------------------------------------------------------------
|
|  6. 将Mifare 1卡的块初始化为其规定的钱包形式。
|   
|    参数: 
|     fd      :  已打开的端口描述符
|	    BlockNum:  经过认证的块号(0-0x80)
|	    uAmount :  初始金额
|   
---------------------------------------------------------------------------*/
unsigned WINAPI Mifare1_InitAmount(                                                                               
	HANDLE        fd,
	unsigned int  BlockNum,
	ULONG         uAmount
	);                      
                     
/*--------------------------------------------------------------------------
|
|  7. 向mifare 1卡的钱包块内添加金额。
|   
|    参数: 
|     fd      :  已打开的端口描述符
|	    BlockNum:  经过认证的块号(0-0x80)
|	    uAmount :  欲添加的金额
|   
---------------------------------------------------------------------------*/
unsigned WINAPI Mifare1_IncreaseAmount(                                                                               
	HANDLE        fd,
	unsigned int  BlockNum,
	ULONG         uAmount
	);                      

/*--------------------------------------------------------------------------
|
|  8. 在Mifare 1卡的钱包块中扣除给定的金额。
|   
|    参数: 
|     fd      :  已打开的端口描述符
|	    BlockNum:  经过认证的块号(0-0x80)
|	    uAmount :  欲扣除的金额
|   
---------------------------------------------------------------------------*/
unsigned WINAPI Mifare1_DecreaseAmount(                                                                               
	HANDLE        fd,
	unsigned int  BlockNum,
	ULONG         uAmount
	);                      

/*--------------------------------------------------------------------------
|
|  9. 去活mifare 1卡，使其进入HALT状态。
|   
|    参数: 
|       fd    :  已打开的端口描述符
|	       
---------------------------------------------------------------------------*/
unsigned WINAPI Mifare1_Halt(                                                                               
	HANDLE        fd
	); 
 
/*-----------------------------------------------------------------------------
|                  
|				                 三. 常用算法及辅助函数   
|
------------------------------------------------------------------------------*/
  
/*------------------------------------------------
|                  
| 1. 十六进制字符串转化为二进制数                                                              
|    参数:
|	       bin:二进制结果串: 0x12,0x34,0xE1,0xFA
|	       asc:十六进制字符串,如"1234E1FA"
|	       len:十六进制字符串长度
|    返回值：
|        二进制结果串的指针 
|
-------------------------------------------------*/
unsigned char * WINAPI CHexToBin(
	unsigned char *bin, 
	unsigned char *asc,
	unsigned int len
	);                                                               

/*---------------------------------------------------
|
| 2. 二进制数转化为16十六进制字符串                                                        
|    参数:
|       asc:十六进制字符串,如"1234E1FA"
| 	    bin:二进制结果串: 0x12,0x34,0xE1,0xFA
|	      len:二进制串长
|    返回值：
|       十六进制字符串的指针 
-----------------------------------------------------*/
unsigned char * WINAPI BinToCHex(
	unsigned char *asc,
	unsigned char *bin,
	unsigned int len
	);	
	
/*-----------------------------------------
|
|   3. 哈什摘要                                                                              
|      参数:	
|  	   len   :要压缩的原文长度
|	     sour  :要压缩的原文
|	     digest:20字节的摘要数据
------------------------------------------*/
void WINAPI SHA1(
	unsigned char *sour,
	unsigned len,
	unsigned char *digest
	);


/*-----------------------------------------------------------
|
| 4. DES加密  
|    参数:  
|	   DESType: =1 加密 
|	            =2 解密 
|    SingleDESKey: 8字节密钥
|    SourDataLen:  源数据长度
|  	 SourData:     源数据 
|    DestData:     目标数据
|    
|    说明: 加密时,当明文长度不时8的倍数时,该函数在明文数据的后
|          面加上16进制数字串"80 00 00...",使其为8的倍数后加密.                                                                  
|    返回值:
|          目标数据的长度
|
-----------------------------------------------------------*/
unsigned WINAPI SingleDES(char DESType,
	unsigned char * SingleDESKey,
	unsigned int  SourDataLen,
	unsigned char *SourData,
	unsigned char *DestData
	);                                           

	
/*--------------------------------------------------------------
|
|  5. 3DES加密     
|     参数:
|        DESType: =1 加密 
|	                =2 解密 
|        TripleDESKey: 16字节密钥 K1K2
|        SourDataLen:  源数据长度
|	       SourData:     源数据 
|        DestData:     目标数据
|
|     返回值：
|        目标数据的长度 
|     说明: 
|        加密时,当明文长度不时8的倍数时,该函数在明文数据的后面
|	       加上16进制数字串"80 00 00...", 使其为8的倍数后加密
|	       加解密过程如下:
|	       DES3-E({K1,K2},P)=E(K1,D(K2,E(K1,P)))
|	       DES3-D({K1,K2},C)=D(K1,E(K2,D(K1,P)))
|
--------------------------------------------------------------*/
unsigned WINAPI TripleDES(
	char DESType,
	unsigned char * TripleDESKey,
	unsigned int  SourDataLen,
	unsigned char *SourData,
	unsigned char *DestData);

 
/*---------------------------------------------------
|
|   6. DES认证码                                                                          
|      参数:	  
|	         SingleMACKey: 8字节密钥 
|	         InitData:     8字节的初始值
|	         SourDataLen:  用来产生mac码的原文长度
|	         SourData:     用来产生mac码的原文 
|	         MactData:     计算出的认证码
|          mac码的计算方法参见有关标准
|   返回值：
|	         认证码的长度为8
----------------------------------------------------*/
unsigned WINAPI SingleMAC(
	unsigned char * SingleMACKey,
	unsigned char *InitData,
	unsigned int  SourDataLen,
	unsigned char *SourData,
	unsigned char *MACData
	); 

	
	
/*------------------------- ----------------------
|  7. 3DES认证码      
|     参数:  
|	         SingleMACKey: 16字节密钥 
|	         InitData:     8字节的初始值
|          SourDataLen:  用来产生mac码的原文长度
|	         SourData:     用来产生mac码的原文 
|          MactData:     计算出的认证码                                                         
|    返回值：
|         认证码的长度为8                                                               
|
---------------------------------------------------*/
unsigned WINAPI TripleMAC(
	unsigned char * SingleMACKey,
	unsigned char *InitData,
	unsigned int  SourDataLen,
	unsigned char *SourData,
	unsigned char *MACData
	);				                                   



#ifdef __cplusplus
}
#endif
